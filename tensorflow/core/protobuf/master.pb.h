// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensorflow/core/protobuf/master.proto

#ifndef PROTOBUF_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto__INCLUDED
#define PROTOBUF_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "tensorflow/core/framework/device_attributes.pb.h"
#include "tensorflow/core/framework/graph.pb.h"
#include "tensorflow/core/protobuf/config.pb.h"
#include "tensorflow/core/protobuf/named_tensor.pb.h"
// @@protoc_insertion_point(includes)

namespace tensorflow {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto();
void protobuf_AssignDesc_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto();
void protobuf_ShutdownFile_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto();

class CloseSessionRequest;
class CloseSessionResponse;
class CreateSessionRequest;
class CreateSessionResponse;
class ExtendSessionRequest;
class ExtendSessionResponse;
class ListDevicesRequest;
class ListDevicesResponse;
class ResetRequest;
class ResetResponse;
class RunStepRequest;
class RunStepResponse;

// ===================================================================

class CreateSessionRequest : public ::google::protobuf::Message {
 public:
  CreateSessionRequest();
  virtual ~CreateSessionRequest();

  CreateSessionRequest(const CreateSessionRequest& from);

  inline CreateSessionRequest& operator=(const CreateSessionRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateSessionRequest& default_instance();

  void Swap(CreateSessionRequest* other);

  // implements Message ----------------------------------------------

  inline CreateSessionRequest* New() const { return New(NULL); }

  CreateSessionRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateSessionRequest& from);
  void MergeFrom(const CreateSessionRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CreateSessionRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .tensorflow.GraphDef graph_def = 1;
  bool has_graph_def() const;
  void clear_graph_def();
  static const int kGraphDefFieldNumber = 1;
  const ::tensorflow::GraphDef& graph_def() const;
  ::tensorflow::GraphDef* mutable_graph_def();
  ::tensorflow::GraphDef* release_graph_def();
  void set_allocated_graph_def(::tensorflow::GraphDef* graph_def);

  // optional .tensorflow.ConfigProto config = 2;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 2;
  const ::tensorflow::ConfigProto& config() const;
  ::tensorflow::ConfigProto* mutable_config();
  ::tensorflow::ConfigProto* release_config();
  void set_allocated_config(::tensorflow::ConfigProto* config);

  // @@protoc_insertion_point(class_scope:tensorflow.CreateSessionRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::tensorflow::GraphDef* graph_def_;
  ::tensorflow::ConfigProto* config_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto();

  void InitAsDefaultInstance();
  static CreateSessionRequest* default_instance_;
};
// -------------------------------------------------------------------

class CreateSessionResponse : public ::google::protobuf::Message {
 public:
  CreateSessionResponse();
  virtual ~CreateSessionResponse();

  CreateSessionResponse(const CreateSessionResponse& from);

  inline CreateSessionResponse& operator=(const CreateSessionResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateSessionResponse& default_instance();

  void Swap(CreateSessionResponse* other);

  // implements Message ----------------------------------------------

  inline CreateSessionResponse* New() const { return New(NULL); }

  CreateSessionResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateSessionResponse& from);
  void MergeFrom(const CreateSessionResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CreateSessionResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string session_handle = 1;
  void clear_session_handle();
  static const int kSessionHandleFieldNumber = 1;
  const ::std::string& session_handle() const;
  void set_session_handle(const ::std::string& value);
  void set_session_handle(const char* value);
  void set_session_handle(const char* value, size_t size);
  ::std::string* mutable_session_handle();
  ::std::string* release_session_handle();
  void set_allocated_session_handle(::std::string* session_handle);

  // optional int64 graph_version = 2;
  void clear_graph_version();
  static const int kGraphVersionFieldNumber = 2;
  ::google::protobuf::int64 graph_version() const;
  void set_graph_version(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:tensorflow.CreateSessionResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr session_handle_;
  ::google::protobuf::int64 graph_version_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto();

  void InitAsDefaultInstance();
  static CreateSessionResponse* default_instance_;
};
// -------------------------------------------------------------------

class ExtendSessionRequest : public ::google::protobuf::Message {
 public:
  ExtendSessionRequest();
  virtual ~ExtendSessionRequest();

  ExtendSessionRequest(const ExtendSessionRequest& from);

  inline ExtendSessionRequest& operator=(const ExtendSessionRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExtendSessionRequest& default_instance();

  void Swap(ExtendSessionRequest* other);

  // implements Message ----------------------------------------------

  inline ExtendSessionRequest* New() const { return New(NULL); }

  ExtendSessionRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExtendSessionRequest& from);
  void MergeFrom(const ExtendSessionRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExtendSessionRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string session_handle = 1;
  void clear_session_handle();
  static const int kSessionHandleFieldNumber = 1;
  const ::std::string& session_handle() const;
  void set_session_handle(const ::std::string& value);
  void set_session_handle(const char* value);
  void set_session_handle(const char* value, size_t size);
  ::std::string* mutable_session_handle();
  ::std::string* release_session_handle();
  void set_allocated_session_handle(::std::string* session_handle);

  // optional .tensorflow.GraphDef graph_def = 2;
  bool has_graph_def() const;
  void clear_graph_def();
  static const int kGraphDefFieldNumber = 2;
  const ::tensorflow::GraphDef& graph_def() const;
  ::tensorflow::GraphDef* mutable_graph_def();
  ::tensorflow::GraphDef* release_graph_def();
  void set_allocated_graph_def(::tensorflow::GraphDef* graph_def);

  // optional int64 current_graph_version = 3;
  void clear_current_graph_version();
  static const int kCurrentGraphVersionFieldNumber = 3;
  ::google::protobuf::int64 current_graph_version() const;
  void set_current_graph_version(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:tensorflow.ExtendSessionRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr session_handle_;
  ::tensorflow::GraphDef* graph_def_;
  ::google::protobuf::int64 current_graph_version_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto();

  void InitAsDefaultInstance();
  static ExtendSessionRequest* default_instance_;
};
// -------------------------------------------------------------------

class ExtendSessionResponse : public ::google::protobuf::Message {
 public:
  ExtendSessionResponse();
  virtual ~ExtendSessionResponse();

  ExtendSessionResponse(const ExtendSessionResponse& from);

  inline ExtendSessionResponse& operator=(const ExtendSessionResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExtendSessionResponse& default_instance();

  void Swap(ExtendSessionResponse* other);

  // implements Message ----------------------------------------------

  inline ExtendSessionResponse* New() const { return New(NULL); }

  ExtendSessionResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExtendSessionResponse& from);
  void MergeFrom(const ExtendSessionResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExtendSessionResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 new_graph_version = 4;
  void clear_new_graph_version();
  static const int kNewGraphVersionFieldNumber = 4;
  ::google::protobuf::int64 new_graph_version() const;
  void set_new_graph_version(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:tensorflow.ExtendSessionResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int64 new_graph_version_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto();

  void InitAsDefaultInstance();
  static ExtendSessionResponse* default_instance_;
};
// -------------------------------------------------------------------

class RunStepRequest : public ::google::protobuf::Message {
 public:
  RunStepRequest();
  virtual ~RunStepRequest();

  RunStepRequest(const RunStepRequest& from);

  inline RunStepRequest& operator=(const RunStepRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RunStepRequest& default_instance();

  void Swap(RunStepRequest* other);

  // implements Message ----------------------------------------------

  inline RunStepRequest* New() const { return New(NULL); }

  RunStepRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RunStepRequest& from);
  void MergeFrom(const RunStepRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RunStepRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string session_handle = 1;
  void clear_session_handle();
  static const int kSessionHandleFieldNumber = 1;
  const ::std::string& session_handle() const;
  void set_session_handle(const ::std::string& value);
  void set_session_handle(const char* value);
  void set_session_handle(const char* value, size_t size);
  ::std::string* mutable_session_handle();
  ::std::string* release_session_handle();
  void set_allocated_session_handle(::std::string* session_handle);

  // repeated .tensorflow.NamedTensorProto feed = 2;
  int feed_size() const;
  void clear_feed();
  static const int kFeedFieldNumber = 2;
  const ::tensorflow::NamedTensorProto& feed(int index) const;
  ::tensorflow::NamedTensorProto* mutable_feed(int index);
  ::tensorflow::NamedTensorProto* add_feed();
  ::google::protobuf::RepeatedPtrField< ::tensorflow::NamedTensorProto >*
      mutable_feed();
  const ::google::protobuf::RepeatedPtrField< ::tensorflow::NamedTensorProto >&
      feed() const;

  // repeated string fetch = 3;
  int fetch_size() const;
  void clear_fetch();
  static const int kFetchFieldNumber = 3;
  const ::std::string& fetch(int index) const;
  ::std::string* mutable_fetch(int index);
  void set_fetch(int index, const ::std::string& value);
  void set_fetch(int index, const char* value);
  void set_fetch(int index, const char* value, size_t size);
  ::std::string* add_fetch();
  void add_fetch(const ::std::string& value);
  void add_fetch(const char* value);
  void add_fetch(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& fetch() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_fetch();

  // repeated string target = 4;
  int target_size() const;
  void clear_target();
  static const int kTargetFieldNumber = 4;
  const ::std::string& target(int index) const;
  ::std::string* mutable_target(int index);
  void set_target(int index, const ::std::string& value);
  void set_target(int index, const char* value);
  void set_target(int index, const char* value, size_t size);
  ::std::string* add_target();
  void add_target(const ::std::string& value);
  void add_target(const char* value);
  void add_target(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& target() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_target();

  // optional .tensorflow.RunOptions options = 5;
  bool has_options() const;
  void clear_options();
  static const int kOptionsFieldNumber = 5;
  const ::tensorflow::RunOptions& options() const;
  ::tensorflow::RunOptions* mutable_options();
  ::tensorflow::RunOptions* release_options();
  void set_allocated_options(::tensorflow::RunOptions* options);

  // @@protoc_insertion_point(class_scope:tensorflow.RunStepRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr session_handle_;
  ::google::protobuf::RepeatedPtrField< ::tensorflow::NamedTensorProto > feed_;
  ::google::protobuf::RepeatedPtrField< ::std::string> fetch_;
  ::google::protobuf::RepeatedPtrField< ::std::string> target_;
  ::tensorflow::RunOptions* options_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto();

  void InitAsDefaultInstance();
  static RunStepRequest* default_instance_;
};
// -------------------------------------------------------------------

class RunStepResponse : public ::google::protobuf::Message {
 public:
  RunStepResponse();
  virtual ~RunStepResponse();

  RunStepResponse(const RunStepResponse& from);

  inline RunStepResponse& operator=(const RunStepResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RunStepResponse& default_instance();

  void Swap(RunStepResponse* other);

  // implements Message ----------------------------------------------

  inline RunStepResponse* New() const { return New(NULL); }

  RunStepResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RunStepResponse& from);
  void MergeFrom(const RunStepResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RunStepResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tensorflow.NamedTensorProto tensor = 1;
  int tensor_size() const;
  void clear_tensor();
  static const int kTensorFieldNumber = 1;
  const ::tensorflow::NamedTensorProto& tensor(int index) const;
  ::tensorflow::NamedTensorProto* mutable_tensor(int index);
  ::tensorflow::NamedTensorProto* add_tensor();
  ::google::protobuf::RepeatedPtrField< ::tensorflow::NamedTensorProto >*
      mutable_tensor();
  const ::google::protobuf::RepeatedPtrField< ::tensorflow::NamedTensorProto >&
      tensor() const;

  // optional .tensorflow.RunMetadata metadata = 2;
  bool has_metadata() const;
  void clear_metadata();
  static const int kMetadataFieldNumber = 2;
  const ::tensorflow::RunMetadata& metadata() const;
  ::tensorflow::RunMetadata* mutable_metadata();
  ::tensorflow::RunMetadata* release_metadata();
  void set_allocated_metadata(::tensorflow::RunMetadata* metadata);

  // @@protoc_insertion_point(class_scope:tensorflow.RunStepResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::tensorflow::NamedTensorProto > tensor_;
  ::tensorflow::RunMetadata* metadata_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto();

  void InitAsDefaultInstance();
  static RunStepResponse* default_instance_;
};
// -------------------------------------------------------------------

class CloseSessionRequest : public ::google::protobuf::Message {
 public:
  CloseSessionRequest();
  virtual ~CloseSessionRequest();

  CloseSessionRequest(const CloseSessionRequest& from);

  inline CloseSessionRequest& operator=(const CloseSessionRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CloseSessionRequest& default_instance();

  void Swap(CloseSessionRequest* other);

  // implements Message ----------------------------------------------

  inline CloseSessionRequest* New() const { return New(NULL); }

  CloseSessionRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CloseSessionRequest& from);
  void MergeFrom(const CloseSessionRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CloseSessionRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string session_handle = 1;
  void clear_session_handle();
  static const int kSessionHandleFieldNumber = 1;
  const ::std::string& session_handle() const;
  void set_session_handle(const ::std::string& value);
  void set_session_handle(const char* value);
  void set_session_handle(const char* value, size_t size);
  ::std::string* mutable_session_handle();
  ::std::string* release_session_handle();
  void set_allocated_session_handle(::std::string* session_handle);

  // @@protoc_insertion_point(class_scope:tensorflow.CloseSessionRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr session_handle_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto();

  void InitAsDefaultInstance();
  static CloseSessionRequest* default_instance_;
};
// -------------------------------------------------------------------

class CloseSessionResponse : public ::google::protobuf::Message {
 public:
  CloseSessionResponse();
  virtual ~CloseSessionResponse();

  CloseSessionResponse(const CloseSessionResponse& from);

  inline CloseSessionResponse& operator=(const CloseSessionResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CloseSessionResponse& default_instance();

  void Swap(CloseSessionResponse* other);

  // implements Message ----------------------------------------------

  inline CloseSessionResponse* New() const { return New(NULL); }

  CloseSessionResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CloseSessionResponse& from);
  void MergeFrom(const CloseSessionResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CloseSessionResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tensorflow.CloseSessionResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto();

  void InitAsDefaultInstance();
  static CloseSessionResponse* default_instance_;
};
// -------------------------------------------------------------------

class ResetRequest : public ::google::protobuf::Message {
 public:
  ResetRequest();
  virtual ~ResetRequest();

  ResetRequest(const ResetRequest& from);

  inline ResetRequest& operator=(const ResetRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResetRequest& default_instance();

  void Swap(ResetRequest* other);

  // implements Message ----------------------------------------------

  inline ResetRequest* New() const { return New(NULL); }

  ResetRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResetRequest& from);
  void MergeFrom(const ResetRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResetRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string container = 1;
  int container_size() const;
  void clear_container();
  static const int kContainerFieldNumber = 1;
  const ::std::string& container(int index) const;
  ::std::string* mutable_container(int index);
  void set_container(int index, const ::std::string& value);
  void set_container(int index, const char* value);
  void set_container(int index, const char* value, size_t size);
  ::std::string* add_container();
  void add_container(const ::std::string& value);
  void add_container(const char* value);
  void add_container(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& container() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_container();

  // @@protoc_insertion_point(class_scope:tensorflow.ResetRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::std::string> container_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto();

  void InitAsDefaultInstance();
  static ResetRequest* default_instance_;
};
// -------------------------------------------------------------------

class ResetResponse : public ::google::protobuf::Message {
 public:
  ResetResponse();
  virtual ~ResetResponse();

  ResetResponse(const ResetResponse& from);

  inline ResetResponse& operator=(const ResetResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResetResponse& default_instance();

  void Swap(ResetResponse* other);

  // implements Message ----------------------------------------------

  inline ResetResponse* New() const { return New(NULL); }

  ResetResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResetResponse& from);
  void MergeFrom(const ResetResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResetResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tensorflow.ResetResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto();

  void InitAsDefaultInstance();
  static ResetResponse* default_instance_;
};
// -------------------------------------------------------------------

class ListDevicesRequest : public ::google::protobuf::Message {
 public:
  ListDevicesRequest();
  virtual ~ListDevicesRequest();

  ListDevicesRequest(const ListDevicesRequest& from);

  inline ListDevicesRequest& operator=(const ListDevicesRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListDevicesRequest& default_instance();

  void Swap(ListDevicesRequest* other);

  // implements Message ----------------------------------------------

  inline ListDevicesRequest* New() const { return New(NULL); }

  ListDevicesRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListDevicesRequest& from);
  void MergeFrom(const ListDevicesRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ListDevicesRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tensorflow.ListDevicesRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto();

  void InitAsDefaultInstance();
  static ListDevicesRequest* default_instance_;
};
// -------------------------------------------------------------------

class ListDevicesResponse : public ::google::protobuf::Message {
 public:
  ListDevicesResponse();
  virtual ~ListDevicesResponse();

  ListDevicesResponse(const ListDevicesResponse& from);

  inline ListDevicesResponse& operator=(const ListDevicesResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListDevicesResponse& default_instance();

  void Swap(ListDevicesResponse* other);

  // implements Message ----------------------------------------------

  inline ListDevicesResponse* New() const { return New(NULL); }

  ListDevicesResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListDevicesResponse& from);
  void MergeFrom(const ListDevicesResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ListDevicesResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tensorflow.DeviceAttributes local_device = 1;
  int local_device_size() const;
  void clear_local_device();
  static const int kLocalDeviceFieldNumber = 1;
  const ::tensorflow::DeviceAttributes& local_device(int index) const;
  ::tensorflow::DeviceAttributes* mutable_local_device(int index);
  ::tensorflow::DeviceAttributes* add_local_device();
  ::google::protobuf::RepeatedPtrField< ::tensorflow::DeviceAttributes >*
      mutable_local_device();
  const ::google::protobuf::RepeatedPtrField< ::tensorflow::DeviceAttributes >&
      local_device() const;

  // repeated .tensorflow.DeviceAttributes remote_device = 2;
  int remote_device_size() const;
  void clear_remote_device();
  static const int kRemoteDeviceFieldNumber = 2;
  const ::tensorflow::DeviceAttributes& remote_device(int index) const;
  ::tensorflow::DeviceAttributes* mutable_remote_device(int index);
  ::tensorflow::DeviceAttributes* add_remote_device();
  ::google::protobuf::RepeatedPtrField< ::tensorflow::DeviceAttributes >*
      mutable_remote_device();
  const ::google::protobuf::RepeatedPtrField< ::tensorflow::DeviceAttributes >&
      remote_device() const;

  // @@protoc_insertion_point(class_scope:tensorflow.ListDevicesResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::tensorflow::DeviceAttributes > local_device_;
  ::google::protobuf::RepeatedPtrField< ::tensorflow::DeviceAttributes > remote_device_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto();

  void InitAsDefaultInstance();
  static ListDevicesResponse* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// CreateSessionRequest

// optional .tensorflow.GraphDef graph_def = 1;
inline bool CreateSessionRequest::has_graph_def() const {
  return !_is_default_instance_ && graph_def_ != NULL;
}
inline void CreateSessionRequest::clear_graph_def() {
  if (GetArenaNoVirtual() == NULL && graph_def_ != NULL) delete graph_def_;
  graph_def_ = NULL;
}
inline const ::tensorflow::GraphDef& CreateSessionRequest::graph_def() const {
  // @@protoc_insertion_point(field_get:tensorflow.CreateSessionRequest.graph_def)
  return graph_def_ != NULL ? *graph_def_ : *default_instance_->graph_def_;
}
inline ::tensorflow::GraphDef* CreateSessionRequest::mutable_graph_def() {
  
  if (graph_def_ == NULL) {
    graph_def_ = new ::tensorflow::GraphDef;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.CreateSessionRequest.graph_def)
  return graph_def_;
}
inline ::tensorflow::GraphDef* CreateSessionRequest::release_graph_def() {
  // @@protoc_insertion_point(field_release:tensorflow.CreateSessionRequest.graph_def)
  
  ::tensorflow::GraphDef* temp = graph_def_;
  graph_def_ = NULL;
  return temp;
}
inline void CreateSessionRequest::set_allocated_graph_def(::tensorflow::GraphDef* graph_def) {
  delete graph_def_;
  graph_def_ = graph_def;
  if (graph_def) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CreateSessionRequest.graph_def)
}

// optional .tensorflow.ConfigProto config = 2;
inline bool CreateSessionRequest::has_config() const {
  return !_is_default_instance_ && config_ != NULL;
}
inline void CreateSessionRequest::clear_config() {
  if (GetArenaNoVirtual() == NULL && config_ != NULL) delete config_;
  config_ = NULL;
}
inline const ::tensorflow::ConfigProto& CreateSessionRequest::config() const {
  // @@protoc_insertion_point(field_get:tensorflow.CreateSessionRequest.config)
  return config_ != NULL ? *config_ : *default_instance_->config_;
}
inline ::tensorflow::ConfigProto* CreateSessionRequest::mutable_config() {
  
  if (config_ == NULL) {
    config_ = new ::tensorflow::ConfigProto;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.CreateSessionRequest.config)
  return config_;
}
inline ::tensorflow::ConfigProto* CreateSessionRequest::release_config() {
  // @@protoc_insertion_point(field_release:tensorflow.CreateSessionRequest.config)
  
  ::tensorflow::ConfigProto* temp = config_;
  config_ = NULL;
  return temp;
}
inline void CreateSessionRequest::set_allocated_config(::tensorflow::ConfigProto* config) {
  delete config_;
  config_ = config;
  if (config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CreateSessionRequest.config)
}

// -------------------------------------------------------------------

// CreateSessionResponse

// optional string session_handle = 1;
inline void CreateSessionResponse::clear_session_handle() {
  session_handle_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateSessionResponse::session_handle() const {
  // @@protoc_insertion_point(field_get:tensorflow.CreateSessionResponse.session_handle)
  return session_handle_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateSessionResponse::set_session_handle(const ::std::string& value) {
  
  session_handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.CreateSessionResponse.session_handle)
}
inline void CreateSessionResponse::set_session_handle(const char* value) {
  
  session_handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.CreateSessionResponse.session_handle)
}
inline void CreateSessionResponse::set_session_handle(const char* value, size_t size) {
  
  session_handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.CreateSessionResponse.session_handle)
}
inline ::std::string* CreateSessionResponse::mutable_session_handle() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.CreateSessionResponse.session_handle)
  return session_handle_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateSessionResponse::release_session_handle() {
  // @@protoc_insertion_point(field_release:tensorflow.CreateSessionResponse.session_handle)
  
  return session_handle_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateSessionResponse::set_allocated_session_handle(::std::string* session_handle) {
  if (session_handle != NULL) {
    
  } else {
    
  }
  session_handle_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), session_handle);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CreateSessionResponse.session_handle)
}

// optional int64 graph_version = 2;
inline void CreateSessionResponse::clear_graph_version() {
  graph_version_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 CreateSessionResponse::graph_version() const {
  // @@protoc_insertion_point(field_get:tensorflow.CreateSessionResponse.graph_version)
  return graph_version_;
}
inline void CreateSessionResponse::set_graph_version(::google::protobuf::int64 value) {
  
  graph_version_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.CreateSessionResponse.graph_version)
}

// -------------------------------------------------------------------

// ExtendSessionRequest

// optional string session_handle = 1;
inline void ExtendSessionRequest::clear_session_handle() {
  session_handle_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ExtendSessionRequest::session_handle() const {
  // @@protoc_insertion_point(field_get:tensorflow.ExtendSessionRequest.session_handle)
  return session_handle_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExtendSessionRequest::set_session_handle(const ::std::string& value) {
  
  session_handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.ExtendSessionRequest.session_handle)
}
inline void ExtendSessionRequest::set_session_handle(const char* value) {
  
  session_handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.ExtendSessionRequest.session_handle)
}
inline void ExtendSessionRequest::set_session_handle(const char* value, size_t size) {
  
  session_handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.ExtendSessionRequest.session_handle)
}
inline ::std::string* ExtendSessionRequest::mutable_session_handle() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.ExtendSessionRequest.session_handle)
  return session_handle_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExtendSessionRequest::release_session_handle() {
  // @@protoc_insertion_point(field_release:tensorflow.ExtendSessionRequest.session_handle)
  
  return session_handle_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExtendSessionRequest::set_allocated_session_handle(::std::string* session_handle) {
  if (session_handle != NULL) {
    
  } else {
    
  }
  session_handle_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), session_handle);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.ExtendSessionRequest.session_handle)
}

// optional .tensorflow.GraphDef graph_def = 2;
inline bool ExtendSessionRequest::has_graph_def() const {
  return !_is_default_instance_ && graph_def_ != NULL;
}
inline void ExtendSessionRequest::clear_graph_def() {
  if (GetArenaNoVirtual() == NULL && graph_def_ != NULL) delete graph_def_;
  graph_def_ = NULL;
}
inline const ::tensorflow::GraphDef& ExtendSessionRequest::graph_def() const {
  // @@protoc_insertion_point(field_get:tensorflow.ExtendSessionRequest.graph_def)
  return graph_def_ != NULL ? *graph_def_ : *default_instance_->graph_def_;
}
inline ::tensorflow::GraphDef* ExtendSessionRequest::mutable_graph_def() {
  
  if (graph_def_ == NULL) {
    graph_def_ = new ::tensorflow::GraphDef;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.ExtendSessionRequest.graph_def)
  return graph_def_;
}
inline ::tensorflow::GraphDef* ExtendSessionRequest::release_graph_def() {
  // @@protoc_insertion_point(field_release:tensorflow.ExtendSessionRequest.graph_def)
  
  ::tensorflow::GraphDef* temp = graph_def_;
  graph_def_ = NULL;
  return temp;
}
inline void ExtendSessionRequest::set_allocated_graph_def(::tensorflow::GraphDef* graph_def) {
  delete graph_def_;
  graph_def_ = graph_def;
  if (graph_def) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.ExtendSessionRequest.graph_def)
}

// optional int64 current_graph_version = 3;
inline void ExtendSessionRequest::clear_current_graph_version() {
  current_graph_version_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ExtendSessionRequest::current_graph_version() const {
  // @@protoc_insertion_point(field_get:tensorflow.ExtendSessionRequest.current_graph_version)
  return current_graph_version_;
}
inline void ExtendSessionRequest::set_current_graph_version(::google::protobuf::int64 value) {
  
  current_graph_version_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.ExtendSessionRequest.current_graph_version)
}

// -------------------------------------------------------------------

// ExtendSessionResponse

// optional int64 new_graph_version = 4;
inline void ExtendSessionResponse::clear_new_graph_version() {
  new_graph_version_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ExtendSessionResponse::new_graph_version() const {
  // @@protoc_insertion_point(field_get:tensorflow.ExtendSessionResponse.new_graph_version)
  return new_graph_version_;
}
inline void ExtendSessionResponse::set_new_graph_version(::google::protobuf::int64 value) {
  
  new_graph_version_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.ExtendSessionResponse.new_graph_version)
}

// -------------------------------------------------------------------

// RunStepRequest

// optional string session_handle = 1;
inline void RunStepRequest::clear_session_handle() {
  session_handle_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RunStepRequest::session_handle() const {
  // @@protoc_insertion_point(field_get:tensorflow.RunStepRequest.session_handle)
  return session_handle_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RunStepRequest::set_session_handle(const ::std::string& value) {
  
  session_handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.RunStepRequest.session_handle)
}
inline void RunStepRequest::set_session_handle(const char* value) {
  
  session_handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.RunStepRequest.session_handle)
}
inline void RunStepRequest::set_session_handle(const char* value, size_t size) {
  
  session_handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.RunStepRequest.session_handle)
}
inline ::std::string* RunStepRequest::mutable_session_handle() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.RunStepRequest.session_handle)
  return session_handle_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RunStepRequest::release_session_handle() {
  // @@protoc_insertion_point(field_release:tensorflow.RunStepRequest.session_handle)
  
  return session_handle_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RunStepRequest::set_allocated_session_handle(::std::string* session_handle) {
  if (session_handle != NULL) {
    
  } else {
    
  }
  session_handle_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), session_handle);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.RunStepRequest.session_handle)
}

// repeated .tensorflow.NamedTensorProto feed = 2;
inline int RunStepRequest::feed_size() const {
  return feed_.size();
}
inline void RunStepRequest::clear_feed() {
  feed_.Clear();
}
inline const ::tensorflow::NamedTensorProto& RunStepRequest::feed(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.RunStepRequest.feed)
  return feed_.Get(index);
}
inline ::tensorflow::NamedTensorProto* RunStepRequest::mutable_feed(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.RunStepRequest.feed)
  return feed_.Mutable(index);
}
inline ::tensorflow::NamedTensorProto* RunStepRequest::add_feed() {
  // @@protoc_insertion_point(field_add:tensorflow.RunStepRequest.feed)
  return feed_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tensorflow::NamedTensorProto >*
RunStepRequest::mutable_feed() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.RunStepRequest.feed)
  return &feed_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorflow::NamedTensorProto >&
RunStepRequest::feed() const {
  // @@protoc_insertion_point(field_list:tensorflow.RunStepRequest.feed)
  return feed_;
}

// repeated string fetch = 3;
inline int RunStepRequest::fetch_size() const {
  return fetch_.size();
}
inline void RunStepRequest::clear_fetch() {
  fetch_.Clear();
}
inline const ::std::string& RunStepRequest::fetch(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.RunStepRequest.fetch)
  return fetch_.Get(index);
}
inline ::std::string* RunStepRequest::mutable_fetch(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.RunStepRequest.fetch)
  return fetch_.Mutable(index);
}
inline void RunStepRequest::set_fetch(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tensorflow.RunStepRequest.fetch)
  fetch_.Mutable(index)->assign(value);
}
inline void RunStepRequest::set_fetch(int index, const char* value) {
  fetch_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tensorflow.RunStepRequest.fetch)
}
inline void RunStepRequest::set_fetch(int index, const char* value, size_t size) {
  fetch_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tensorflow.RunStepRequest.fetch)
}
inline ::std::string* RunStepRequest::add_fetch() {
  // @@protoc_insertion_point(field_add_mutable:tensorflow.RunStepRequest.fetch)
  return fetch_.Add();
}
inline void RunStepRequest::add_fetch(const ::std::string& value) {
  fetch_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tensorflow.RunStepRequest.fetch)
}
inline void RunStepRequest::add_fetch(const char* value) {
  fetch_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tensorflow.RunStepRequest.fetch)
}
inline void RunStepRequest::add_fetch(const char* value, size_t size) {
  fetch_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tensorflow.RunStepRequest.fetch)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RunStepRequest::fetch() const {
  // @@protoc_insertion_point(field_list:tensorflow.RunStepRequest.fetch)
  return fetch_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RunStepRequest::mutable_fetch() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.RunStepRequest.fetch)
  return &fetch_;
}

// repeated string target = 4;
inline int RunStepRequest::target_size() const {
  return target_.size();
}
inline void RunStepRequest::clear_target() {
  target_.Clear();
}
inline const ::std::string& RunStepRequest::target(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.RunStepRequest.target)
  return target_.Get(index);
}
inline ::std::string* RunStepRequest::mutable_target(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.RunStepRequest.target)
  return target_.Mutable(index);
}
inline void RunStepRequest::set_target(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tensorflow.RunStepRequest.target)
  target_.Mutable(index)->assign(value);
}
inline void RunStepRequest::set_target(int index, const char* value) {
  target_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tensorflow.RunStepRequest.target)
}
inline void RunStepRequest::set_target(int index, const char* value, size_t size) {
  target_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tensorflow.RunStepRequest.target)
}
inline ::std::string* RunStepRequest::add_target() {
  // @@protoc_insertion_point(field_add_mutable:tensorflow.RunStepRequest.target)
  return target_.Add();
}
inline void RunStepRequest::add_target(const ::std::string& value) {
  target_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tensorflow.RunStepRequest.target)
}
inline void RunStepRequest::add_target(const char* value) {
  target_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tensorflow.RunStepRequest.target)
}
inline void RunStepRequest::add_target(const char* value, size_t size) {
  target_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tensorflow.RunStepRequest.target)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RunStepRequest::target() const {
  // @@protoc_insertion_point(field_list:tensorflow.RunStepRequest.target)
  return target_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RunStepRequest::mutable_target() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.RunStepRequest.target)
  return &target_;
}

// optional .tensorflow.RunOptions options = 5;
inline bool RunStepRequest::has_options() const {
  return !_is_default_instance_ && options_ != NULL;
}
inline void RunStepRequest::clear_options() {
  if (GetArenaNoVirtual() == NULL && options_ != NULL) delete options_;
  options_ = NULL;
}
inline const ::tensorflow::RunOptions& RunStepRequest::options() const {
  // @@protoc_insertion_point(field_get:tensorflow.RunStepRequest.options)
  return options_ != NULL ? *options_ : *default_instance_->options_;
}
inline ::tensorflow::RunOptions* RunStepRequest::mutable_options() {
  
  if (options_ == NULL) {
    options_ = new ::tensorflow::RunOptions;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.RunStepRequest.options)
  return options_;
}
inline ::tensorflow::RunOptions* RunStepRequest::release_options() {
  // @@protoc_insertion_point(field_release:tensorflow.RunStepRequest.options)
  
  ::tensorflow::RunOptions* temp = options_;
  options_ = NULL;
  return temp;
}
inline void RunStepRequest::set_allocated_options(::tensorflow::RunOptions* options) {
  delete options_;
  options_ = options;
  if (options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.RunStepRequest.options)
}

// -------------------------------------------------------------------

// RunStepResponse

// repeated .tensorflow.NamedTensorProto tensor = 1;
inline int RunStepResponse::tensor_size() const {
  return tensor_.size();
}
inline void RunStepResponse::clear_tensor() {
  tensor_.Clear();
}
inline const ::tensorflow::NamedTensorProto& RunStepResponse::tensor(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.RunStepResponse.tensor)
  return tensor_.Get(index);
}
inline ::tensorflow::NamedTensorProto* RunStepResponse::mutable_tensor(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.RunStepResponse.tensor)
  return tensor_.Mutable(index);
}
inline ::tensorflow::NamedTensorProto* RunStepResponse::add_tensor() {
  // @@protoc_insertion_point(field_add:tensorflow.RunStepResponse.tensor)
  return tensor_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tensorflow::NamedTensorProto >*
RunStepResponse::mutable_tensor() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.RunStepResponse.tensor)
  return &tensor_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorflow::NamedTensorProto >&
RunStepResponse::tensor() const {
  // @@protoc_insertion_point(field_list:tensorflow.RunStepResponse.tensor)
  return tensor_;
}

// optional .tensorflow.RunMetadata metadata = 2;
inline bool RunStepResponse::has_metadata() const {
  return !_is_default_instance_ && metadata_ != NULL;
}
inline void RunStepResponse::clear_metadata() {
  if (GetArenaNoVirtual() == NULL && metadata_ != NULL) delete metadata_;
  metadata_ = NULL;
}
inline const ::tensorflow::RunMetadata& RunStepResponse::metadata() const {
  // @@protoc_insertion_point(field_get:tensorflow.RunStepResponse.metadata)
  return metadata_ != NULL ? *metadata_ : *default_instance_->metadata_;
}
inline ::tensorflow::RunMetadata* RunStepResponse::mutable_metadata() {
  
  if (metadata_ == NULL) {
    metadata_ = new ::tensorflow::RunMetadata;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.RunStepResponse.metadata)
  return metadata_;
}
inline ::tensorflow::RunMetadata* RunStepResponse::release_metadata() {
  // @@protoc_insertion_point(field_release:tensorflow.RunStepResponse.metadata)
  
  ::tensorflow::RunMetadata* temp = metadata_;
  metadata_ = NULL;
  return temp;
}
inline void RunStepResponse::set_allocated_metadata(::tensorflow::RunMetadata* metadata) {
  delete metadata_;
  metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.RunStepResponse.metadata)
}

// -------------------------------------------------------------------

// CloseSessionRequest

// optional string session_handle = 1;
inline void CloseSessionRequest::clear_session_handle() {
  session_handle_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CloseSessionRequest::session_handle() const {
  // @@protoc_insertion_point(field_get:tensorflow.CloseSessionRequest.session_handle)
  return session_handle_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CloseSessionRequest::set_session_handle(const ::std::string& value) {
  
  session_handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.CloseSessionRequest.session_handle)
}
inline void CloseSessionRequest::set_session_handle(const char* value) {
  
  session_handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.CloseSessionRequest.session_handle)
}
inline void CloseSessionRequest::set_session_handle(const char* value, size_t size) {
  
  session_handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.CloseSessionRequest.session_handle)
}
inline ::std::string* CloseSessionRequest::mutable_session_handle() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.CloseSessionRequest.session_handle)
  return session_handle_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CloseSessionRequest::release_session_handle() {
  // @@protoc_insertion_point(field_release:tensorflow.CloseSessionRequest.session_handle)
  
  return session_handle_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CloseSessionRequest::set_allocated_session_handle(::std::string* session_handle) {
  if (session_handle != NULL) {
    
  } else {
    
  }
  session_handle_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), session_handle);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CloseSessionRequest.session_handle)
}

// -------------------------------------------------------------------

// CloseSessionResponse

// -------------------------------------------------------------------

// ResetRequest

// repeated string container = 1;
inline int ResetRequest::container_size() const {
  return container_.size();
}
inline void ResetRequest::clear_container() {
  container_.Clear();
}
inline const ::std::string& ResetRequest::container(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.ResetRequest.container)
  return container_.Get(index);
}
inline ::std::string* ResetRequest::mutable_container(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.ResetRequest.container)
  return container_.Mutable(index);
}
inline void ResetRequest::set_container(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tensorflow.ResetRequest.container)
  container_.Mutable(index)->assign(value);
}
inline void ResetRequest::set_container(int index, const char* value) {
  container_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tensorflow.ResetRequest.container)
}
inline void ResetRequest::set_container(int index, const char* value, size_t size) {
  container_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tensorflow.ResetRequest.container)
}
inline ::std::string* ResetRequest::add_container() {
  // @@protoc_insertion_point(field_add_mutable:tensorflow.ResetRequest.container)
  return container_.Add();
}
inline void ResetRequest::add_container(const ::std::string& value) {
  container_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tensorflow.ResetRequest.container)
}
inline void ResetRequest::add_container(const char* value) {
  container_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tensorflow.ResetRequest.container)
}
inline void ResetRequest::add_container(const char* value, size_t size) {
  container_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tensorflow.ResetRequest.container)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ResetRequest::container() const {
  // @@protoc_insertion_point(field_list:tensorflow.ResetRequest.container)
  return container_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ResetRequest::mutable_container() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.ResetRequest.container)
  return &container_;
}

// -------------------------------------------------------------------

// ResetResponse

// -------------------------------------------------------------------

// ListDevicesRequest

// -------------------------------------------------------------------

// ListDevicesResponse

// repeated .tensorflow.DeviceAttributes local_device = 1;
inline int ListDevicesResponse::local_device_size() const {
  return local_device_.size();
}
inline void ListDevicesResponse::clear_local_device() {
  local_device_.Clear();
}
inline const ::tensorflow::DeviceAttributes& ListDevicesResponse::local_device(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.ListDevicesResponse.local_device)
  return local_device_.Get(index);
}
inline ::tensorflow::DeviceAttributes* ListDevicesResponse::mutable_local_device(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.ListDevicesResponse.local_device)
  return local_device_.Mutable(index);
}
inline ::tensorflow::DeviceAttributes* ListDevicesResponse::add_local_device() {
  // @@protoc_insertion_point(field_add:tensorflow.ListDevicesResponse.local_device)
  return local_device_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tensorflow::DeviceAttributes >*
ListDevicesResponse::mutable_local_device() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.ListDevicesResponse.local_device)
  return &local_device_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorflow::DeviceAttributes >&
ListDevicesResponse::local_device() const {
  // @@protoc_insertion_point(field_list:tensorflow.ListDevicesResponse.local_device)
  return local_device_;
}

// repeated .tensorflow.DeviceAttributes remote_device = 2;
inline int ListDevicesResponse::remote_device_size() const {
  return remote_device_.size();
}
inline void ListDevicesResponse::clear_remote_device() {
  remote_device_.Clear();
}
inline const ::tensorflow::DeviceAttributes& ListDevicesResponse::remote_device(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.ListDevicesResponse.remote_device)
  return remote_device_.Get(index);
}
inline ::tensorflow::DeviceAttributes* ListDevicesResponse::mutable_remote_device(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.ListDevicesResponse.remote_device)
  return remote_device_.Mutable(index);
}
inline ::tensorflow::DeviceAttributes* ListDevicesResponse::add_remote_device() {
  // @@protoc_insertion_point(field_add:tensorflow.ListDevicesResponse.remote_device)
  return remote_device_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tensorflow::DeviceAttributes >*
ListDevicesResponse::mutable_remote_device() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.ListDevicesResponse.remote_device)
  return &remote_device_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorflow::DeviceAttributes >&
ListDevicesResponse::remote_device() const {
  // @@protoc_insertion_point(field_list:tensorflow.ListDevicesResponse.remote_device)
  return remote_device_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace tensorflow

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto__INCLUDED
